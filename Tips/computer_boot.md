# 计算机的启动过程

0. ## boot的含义

   boot原来的意思是靴子，"启动"与靴子有什么关系呢？ 原来，这里的boot是bootstrap（鞋带）的缩写，它来自一句谚语：

 `"pull oneself up by one's bootstraps"`
   字面意思是"拽着鞋带把自己拉起来"，这当然是不可能的事情。最早的时候，工程师们用它来比喻，计算机启动是一个很矛盾的过程：必须先运行程序，然后计算机才能启动，但是计算机不启动就无法运行程序！

   早期真的是这样，必须想尽各种办法，把一小段程序装进内存，然后计算机才能正常运行。所以，工程师们把这个过程叫做"拉鞋带"，久而久之就简称为boot了。

1. ## BIOS

   上个世纪70年代初，"只读内存"（read-only memory，缩写为ROM）发明，开机程序被刷入ROM芯片，计算机通电后，第一件事就是读取它。

   这块芯片里的程序叫做"基本輸出輸入系統"（Basic Input/Output System），简称为BIOS。

   1. ### 硬件自检

      BIOS程序首先检查，计算机硬件能否满足运行的基本条件，这叫做"硬件自检"（Power-On Self-Test），缩写为POST

      如果硬件出现问题，主板会发出不同含义的蜂鸣，启动中止。如果没有问题，屏幕就会显示出CPU、内存、硬盘等信息。

   2. ### 启动顺序

      硬件自检完成后，BIOS把控制权转交给下一阶段的启动程序。

      这时，BIOS需要知道，"下一阶段的启动程序"具体存放在哪一个设备。也就是说，BIOS需要有一个外部储存设备的排序，排在前面的设备就是优先转交控制权的设备。这种排序叫做"启动顺序"（Boot Sequence）。

      打开BIOS的操作界面，里面有一项就是"设定启动顺序"。

2. ## 主引导记录

   BIOS按照"启动顺序"，把控制权转交给排在第一位的储存设备。

   这时，计算机读取该设备的第一个扇区，也就是读取最前面的512个字节。如果这512个字节的最后两个字节是0x55和0xAA，表明这个设备可以用于启动；如果不是，表明设备不能用于启动，控制权于是被转交给"启动顺序"中的下一个设备。

   这最前面的512个字节，就叫做"主引导记录"（Master boot record，缩写为MBR）。

   1. ### 主引导记录结构

      "主引导记录"只有512个字节，放不了太多东西。它的主要作用是，告诉计算机到硬盘的哪一个位置去找操作系统。

      主引导记录由三个部分组成：

      

``` 
      　　（1） 第1-446字节：调用操作系统的机器码。
      
      　　（2） 第447-510字节：分区表（Partition table）。
      
      　　（3） 第511-512字节：主引导记录签名（0x55和0xAA）。
```

      其中，第二部分"分区表"的作用，是将硬盘分成若干个区。

   2. ### 分区表

      硬盘分区有很多好处。考虑到每个区可以安装不同的操作系统，"主引导记录"因此必须知道将控制权转交给哪个区。

      分区表的长度只有64个字节，里面又分成四项，每项16个字节。所以，一个硬盘最多只能分四个一级分区，又叫做"主分区"。

      每个主分区的16个字节，由6个部分组成：

      

``` 
      　　（1） 第1个字节：如果为0x80，就表示该主分区是激活分区，控制权要转交给这个分区。四个主分区里面只能有一个是激活的。
      
      　　（2） 第2-4个字节：主分区第一个扇区的物理位置（柱面、磁头、扇区号等等）。
      
      　　（3） 第5个字节：主分区类型。
      
      　　（4） 第6-8个字节：主分区最后一个扇区的物理位置。
      
      　　（5） 第9-12字节：该主分区第一个扇区的逻辑地址。
      
      　　（6） 第13-16字节：主分区的扇区总数。
```

      最后的四个字节（"主分区的扇区总数"），决定了这个主分区的长度。也就是说，一个主分区的扇区总数最多不超过2的32次方。
    
      如果每个扇区为512个字节，就意味着单个分区最大不超过2TB。再考虑到扇区的逻辑地址也是32位，所以单个硬盘可利用的空间最大也不超过2TB。如果想使用更大的硬盘，只有2个方法：一是提高每个扇区的字节数，二是增加扇区总数。

3. ## 硬盘启动

   这时，计算机的控制权就要转交给硬盘的某个分区了，这里又分成三种情况。

   1. ### 卷引导记录

      四个主分区里面，只有一个是激活的。计算机会读取激活分区的第一个扇区，叫做"卷引导记录"（Volume boot record，缩写为VBR）。

      "卷引导记录"的主要作用是，告诉计算机，操作系统在这个分区里的位置。然后，计算机就会加载操作系统了。

   2. ### 扩展分区和逻辑分区

      随着硬盘越来越大，四个主分区已经不够了，需要更多的分区。但是，分区表只有四项，因此规定有且仅有一个区可以被定义成"扩展分区"（Extended partition）。

      所谓"扩展分区"，就是指这个区里面又分成多个区。这种分区里面的分区，就叫做"逻辑分区"（logical partition）。

      计算机先读取扩展分区的第一个扇区，叫做"扩展引导记录"（Extended boot record，缩写为EBR）。它里面也包含一张64字节的分区表，但是最多只有两项（也就是两个逻辑分区）。

      计算机接着读取第二个逻辑分区的第一个扇区，再从里面的分区表中找到第三个逻辑分区的位置，以此类推，直到某个逻辑分区的分区表只包含它自身为止（即只有一个分区项）。因此，扩展分区可以包含无数个逻辑分区。

      但是，似乎很少通过这种方式启动操作系统。如果操作系统确实安装在扩展分区，一般采用下一种方式启动。

   3. ### 启动管理器

      在这种情况下，计算机读取"主引导记录"前面446字节的机器码之后，不再把控制权转交给某一个分区，而是运行事先安装的"启动管理器"（boot loader），由用户选择启动哪一个操作系统。

      Linux环境中，目前最流行的启动管理器是Grub

4. ## 操作系统

   控制权转交给操作系统后，操作系统的内核首先被载入内存。

   以Linux系统为例，先载入/boot目录下面的kernel。内核加载成功后，第一个运行的程序是/sbin/init。它根据配置文件（Debian系统是/etc/initab）产生init进程。这是Linux启动后的第一个进程，pid进程编号为1，其他进程都是它的后代。

   然后，init线程加载系统的各个模块，比如窗口程序和网络程序，直至执行/bin/login程序，跳出登录界面，等待用户输入用户名和密码。

   至此，全部启动过程完成。

5. ## 一些细节

   1. ### 寻址概念

      我们先来一起复习计算机原理之类的课程中对于CPU寻址的一些概念吧。首先，我们的内核使用32位的地址总线来寻址，所以能编址出2的32次方，也就是4G的地址空间。那么第一个问题是，这4G的空间指向哪里？我想大多数读者的第一反应都是内存吧？我们知道在主板上除了内存还有BIOS、显卡、声卡、网卡3等外部设备，CPU需要和这些外设进行通信。那么实现通信自然就得有地址，不然怎么表示数据的去向呢？比如显卡内部就有自己的一些存储单元4。在x86下，当需要访问这些存储单元的时候，就需要给予不同的访问地址来区分每一个读写单元。

   2. ### 端口编指

      说到这里，我们需要引出两个专业名词：端口统一编址和端口独立编址。还记得我们刚说的4G地址空间吗？所谓的端口统一编址就是把所有和外设存储单元对应的端口直接编址在这4G的地址空间里，当我们对某一个地址进行访问的时候实际上是在访问某个外设的存储单元。而端口独立编址就是说这些端口没有编址在地址空间里，而是另行独立编址。而x86架构部分的采用了端口独立编址，又部分的采用了端口统一编址。部分外设的部分存储单元直接可以通过某个内存地址访问，而其他部分在一个独立的端口地址空间中，需要使用in/out指令去访问，我们用到的时候再来细说。

   3. ### CPU重置

      我们从按下电源开始。首先是CPU重置。主板加电之后在电压尚未稳定之前，主板上的北桥控制芯片会向CPU发出重置信号（Reset），此时CPU进行初始化。当电压稳定后，控制芯片会撤销Reset信号，CPU便开始了模式化的工作。此时形成的第一条指令的地址是0xFFFFFFF06，从这里开始，CPU就进入了一个“取指令-翻译指令-执行”的循环了。所以我们需要做的就是在各个阶段提供给CPU相关的数据，以完成这个“接力赛”。这个接力过程中任何一个环节如果出现致命问题，其导致的直接后果就是宕机。死机是最好的结果，最坏的结果是程序在“默默的”破坏我们的数据，所以一定要谨慎对待。

   4. ### BIOS过程

      那么，这个地址指向哪呢？大家一定想到了，它指向BIOS芯片里。我们刚刚说过，在4G的地址空间里，有一些地址是分给外设的，这个地址便是映射到BIOS的。我们知道，计算机刚加电的时候内存等芯片尚未初始化，所以也只能是指向BIOS芯片里已经被“固化”的指令了。

      紧接着就是BIOS的POST（Power On Self Test，上电自检）过程了，BIOS对计算机各个部件开始初始化，如果有错误会给出报警音。当BIOS完成这些工作之后，它的任务就是在外部存储设备中寻找操作系统，而我们最常用的外存自然就是硬盘了。自己安装过操作系统的读者应该都设置过BIOS选项吧？BIOS里面就有一张启动设备表7，BIOS会按照这个表里面列出的顺序查找可启动设备。那么怎么知道该设备是否可以启动呢？规则其实很简单：如果这个存储设备的第一个扇区中512个字节8的最后两个字节是0x55和0xAA，那么该存储设备就是可启动的。这是一个约定，所以BIOS会对这个列表中的设备逐一检测，只要有一个设备满足要求，后续的设备将不再测试。

      当BIOS找到可启动的设备后，便将该设备的第一个扇区加载到内存的0x7C00地址处，并且跳转过去执行。而我们要做的事情，便是从构造这个可启动的扇区开始。

   5. ### Bootloader

      因为一个扇区只有512字节，放不下太多的代码，所以常规的做法便是在这里写下载入操作系统内核的代码9，这段代码就是所谓的bootloader程序。一般意义上的bootloader负责将软硬件的环境设置到一个合适的状态，然后加载操作系统内核并且移交执行权限。而GRUB是一个来自GNU项目的多操作系统启动程序。它是多启动规范的实现，允许用户可以在计算机内同时拥有多个操作系统，并在计算机启动时选择希望运行的操作系统。